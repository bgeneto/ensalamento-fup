#!/usr/bin/env python3
"""
Load historical semester allocations from CSV file.

This script loads historical course/room allocations from a CSV file,
parsing the data and creating AlocacaoSemestral records for the semester
history (RF-006.6 - rules based on historical allocations).

Usage:
    python load_historical_allocations.py [--dry-run] [--force] [CSV_FILE]

Arguments:
    CSV_FILE: Path to CSV file (default: docs/Ensalamento Oferta 2-2025.csv)

Options:
    --dry-run: Show what would be done without making changes
    --force: Overwrite existing allocations for the same conflicts
"""

import csv
import re
from pathlib import Path
from typing import List, Optional, Dict, Tuple, NamedTuple
from argparse import ArgumentParser, RawDescriptionHelpFormatter

from sqlalchemy.orm import Session

from src.config.database import get_db_session
from src.repositories.semestre import SemestreRepository
from src.repositories.alocacao import AlocacaoRepository
from src.repositories.disciplina import DisciplinaRepository
from src.repositories.sala import SalaRepository
from src.repositories.dia_semana import DiaSemanaRepository
from src.repositories.horario_bloco import HorarioBlocoRepository
from src.repositories.base import BaseRepository
from src.models.allocation import ReservaEsporadica, AlocacaoSemestral

# We'll create our own DTO since the schema files are misaligned with actual models

# Regex patterns for parsing course data
# Course codes: 3-5 letters + 4 digits, may optionally end with dash for no-turma courses
# Format: CODE - NAME - TURMA (where TURMA is optional T followed by number)
COURSE_PATTERN = re.compile(r"^([A-Z]{3,9}\d{4}-?)\s*-\s*([^-\n]+?)(?:\s*-\s*T(\d+))?$")
RESERVATION_PATTERN = re.compile(
    r"^(Ledoc|EducA√ß√£o|biblioteca|audit√≥rio|[A-Z][a-z]{2,})$", re.IGNORECASE
)


class ParsedAllocation(NamedTuple):
    """Parsed allocation data from CSV cell."""

    codigo_disciplina: Optional[str]
    nome_disciplina: Optional[str]
    turma_disciplina: Optional[str]
    is_reservation: bool
    titulo_evento: Optional[str]


class ReservaEsporadicaRepository(BaseRepository):
    """Repository for ReservaEsporadica operations."""

    def __init__(self, session: Session):
        super().__init__(session, ReservaEsporadica)


class CSVAllocator:
    """Handles loading historical allocations from CSV."""

    def __init__(
        self,
        session: Session,
        dry_run: bool = False,
        force: bool = False,
        semester_name: str = "2025-2",
    ):
        self.session = session
        self.dry_run = dry_run
        self.force = force
        self.semestre_name = semester_name

        # Initialize repositories
        self.sem_repo = SemestreRepository(session)
        self.aloc_repo = AlocacaoRepository(session)
        self.reserva_repo = ReservaEsporadicaRepository(session)
        self.demanda_repo = DisciplinaRepository(session)
        self.sala_repo = SalaRepository(session)
        self.dia_repo = DiaSemanaRepository(session)
        self.horario_repo = HorarioBlocoRepository(session)

        # Stats
        self.stats = {
            "rows_processed": 0,
            "allocations_created": 0,
            "reservas_created": 0,
            "demandas_created": 0,
            "conflicts_skipped": 0,
            "errors": 0,
        }

    def get_semestre(self):
        """Get the 2025-2 semester."""
        return self.sem_repo.get_by_name(self.semestre_name)

    def parse_allocation_cell(self, cell_value: str) -> ParsedAllocation:
        """
        Parse a CSV cell containing allocation data.

        First tries to parse as course code, if no valid course code can be inferred,
        treats the whole string as a reservation title.
        """
        if not cell_value or cell_value.strip() == "":
            return ParsedAllocation(None, None, None, False, None)

        cell_value = cell_value.strip()

        # First check if it's a known reservation type (Ledoc, EducA√ß√£o, etc.)
        if RESERVATION_PATTERN.match(cell_value):
            return ParsedAllocation(None, None, None, True, cell_value)

        # Try to parse as course by splitting on " - "
        parts = cell_value.split(" - ")
        if len(parts) >= 2:
            # Get potential code from first part
            codigo_raw = parts[0].strip()
            # Remove trailing dash from code if present (codes should never end with -)
            codigo = codigo_raw.rstrip("-")

            # Verify the code looks valid (3-5 letters + 4 digits, no trailing dash)
            if re.match(r"^[A-Z]{3,5}\d{4}$", codigo):
                # Valid code, parse the rest
                remaining_parts = parts[1:]

                # Check if last part looks like a turma indicator (T followed by digits)
                last_part = remaining_parts[-1].strip() if remaining_parts else ""
                if last_part.startswith("T") and last_part[1:].isdigit():
                    # Last part is turma
                    nome_parts = remaining_parts[:-1]
                    turma_raw = last_part[1:]
                else:
                    # No explicit turma, assume all remaining parts are name
                    nome_parts = remaining_parts
                    turma_raw = ""

                # Join name parts back with " - " (preserves internal dashes)
                nome = " - ".join(part.strip() for part in nome_parts)

                # Clean up name
                nome = nome.strip()

                # If no turma found, use default "1"
                if not turma_raw:
                    turma = "1"
                else:
                    # Ensure turma is numeric only
                    turma = turma_raw if turma_raw.isdigit() else "1"

                return ParsedAllocation(codigo, nome, turma, False, None)

        # If no course pattern matches AND not a known reservation type,
        # treat the whole string as a reservation title
        return ParsedAllocation(None, None, None, True, cell_value)

    def find_demanda(
        self,
        semestre_id: int,
        codigo: str,
        turma: str,
        horario_sigaa: Optional[str] = None,
        nome_disciplina: Optional[str] = None,
    ) -> Optional[int]:
        """
        Find existing demanda ID by semester, code, and turma.

        If not found and horario_sigaa provided, create new demanda.
        """
        # Try exact match first
        demandas = self.demanda_repo.get_by_semestre(semestre_id)
        for demanda in demandas:
            if (
                demanda.codigo_disciplina == codigo
                and demanda.turma_disciplina == turma
            ):
                return demanda.id

        # If not found and we have horario, create new demanda
        if horario_sigaa:
            print(f"  ‚ö†Ô∏è Demanda not found for {codigo}, T{turma}, creating...")
            demanda_data = {
                "semestre_id": semestre_id,
                "codigo_disciplina": codigo,
                "nome_disciplina": nome_disciplina
                or f"Disciplina {codigo}",  # Use parsed name or placeholder
                "turma_disciplina": turma,
                "horario_sigaa_bruto": horario_sigaa,
                "vagas_disciplina": 30,  # Default
                "professores_disciplina": "",  # Empty for now
            }

            if not self.dry_run:
                demanda = self.demanda_repo.create(demanda_data)
                self.stats["demandas_created"] += 1
                return demanda.id
            else:
                print(f"    [DRY RUN] Would create demanda: {codigo} (T{turma})")
                return None  # In dry run, can't return real ID

        return None

    def process_allocation(
        self,
        semestre_id: int,
        sala_id: int,
        dia_id: int,
        bloco: str,
        allocation: ParsedAllocation,
        demanda_id: Optional[int] = None,
    ):
        """Process a single allocation (course or reservation)."""

        if allocation.is_reservation:
            # Create reservation using model fields: sala_id, username_solicitante, titulo_evento, data_reserva, codigo_bloco
            reserva_data = {
                "sala_id": sala_id,
                "username_solicitante": "admin",  # Admin user
                "titulo_evento": allocation.titulo_evento or "Reserva Hist√≥rica",
                "data_reserva": f"2025-{(dia_id-2)*7 + 1:02d}-15",  # Fake date based on weekday
                "codigo_bloco": bloco,
            }

            # Check for conflicts
            if self.aloc_repo.check_conflict(sala_id, dia_id, bloco):
                if not self.force:
                    print(
                        f"  ‚ö†Ô∏è Skipping reserva conflict: sala {sala_id}, {dia_id}, {bloco}"
                    )
                    self.stats["conflicts_skipped"] += 1
                    return
                else:
                    print(
                        f"  üîÑ Force-overwriting reserva conflict: sala {sala_id}, {dia_id}, {bloco}"
                    )

            if not self.dry_run:
                try:
                    # Create reserva object directly since schemas are misaligned
                    reserva_obj = ReservaEsporadica(**reserva_data)
                    self.session.add(reserva_obj)
                    self.session.flush()
                    self.stats["reservas_created"] += 1
                except Exception as e:
                    print(f"  ‚ùå Error creating reserva: {e}")
                    self.stats["errors"] += 1
            else:
                print(f"    [DRY RUN] Would create reserva: {allocation.titulo_evento}")

        else:
            # For courses, demanda_id should already be provided
            if demanda_id is None:
                print(
                    f"  ‚ùå No demanda_id provided for course allocation: {allocation.codigo_disciplina}-{allocation.turma_disciplina}"
                )
                return

            aloc_data = {
                "semestre_id": semestre_id,
                "demanda_id": demanda_id,
                "sala_id": sala_id,
                "dia_semana_id": dia_id,
                "codigo_bloco": bloco,
            }

            # Check for conflicts
            if self.aloc_repo.check_conflict(sala_id, dia_id, bloco):
                if not self.force:
                    print(
                        f"  ‚ö†Ô∏è Skipping allocation conflict: sala {sala_id}, {dia_id}, {bloco}"
                    )
                    self.stats["conflicts_skipped"] += 1
                    return
                else:
                    print(
                        f"  üîÑ Force-overwriting allocation conflict: sala {sala_id}, {dia_id}, {bloco}"
                    )

            if not self.dry_run:
                try:
                    aloc_obj = AlocacaoSemestral(**aloc_data)
                    self.session.add(aloc_obj)
                    self.session.flush()
                    self.stats["allocations_created"] += 1
                except Exception as e:
                    print(f"  ‚ùå Error creating allocation: {e}")
                    self.stats["errors"] += 1
            else:
                print(
                    f"    [DRY RUN] Would create allocation: {allocation.codigo_disciplina} in sala {sala_id}"
                )

    def process_csv_row(
        self, row: List[str], room_mapping: List[str], semestre_id: int
    ):
        """Process a single CSV row containing time block + allocations."""
        self.stats["rows_processed"] += 1

        # First column is the time block (e.g., "2M12")
        time_slot = row[0].strip()
        if not time_slot:
            print(f"  ‚ö†Ô∏è Skipping empty time slot in row {self.stats['rows_processed']}")
            return

        # Parse time slot: digit(s) + turn + slots
        match = re.match(r"^(\d+)([MTN])(\d+)$", time_slot)
        if not match:
            print(f"  ‚ö†Ô∏è Invalid time slot format: {time_slot}")
            self.stats["errors"] += 1
            return

        dia_sigaa = int(match.group(1))
        turno = match.group(2)  # M, T, or N
        slots_str = match.group(3)  # e.g., "34" (slots 3 and 4)

        # Split into atomic blocks (e.g., "34" -> ["3", "4"] -> ["M3", "M4"])
        atomic_blocks = [f"{turno}{slot}" for slot in slots_str]

        # Get dia_semana ORM object
        dia_obj = self.dia_repo.get_by_id_sigaa(dia_sigaa)
        if not dia_obj:
            print(f"  ‚ö†Ô∏è Day {dia_sigaa} not found")
            self.stats["errors"] += 1
            return

        print(
            f"Processing {time_slot} (dia {dia_sigaa}, atomic blocks: {atomic_blocks})"
        )

        # Process each allocation column (skip first column which is time slot)
        for i, allocation_cell in enumerate(row[1:], 1):
            if i > len(room_mapping):
                break

            sala_nome = room_mapping[i - 1]
            cell_value = allocation_cell.strip()

            if not cell_value:
                continue  # Empty cell, skip

            # Get sala ORM object
            from src.models.inventory import Sala

            sala_orm = self.session.query(Sala).filter(Sala.nome == sala_nome).first()
            if not sala_orm:
                print(f"  ‚ö†Ô∏è Room {sala_nome} not found")
                self.stats["errors"] += 1
                continue
            sala = self.sala_repo.orm_to_dto(sala_orm)

            # Parse the allocation
            allocation = self.parse_allocation_cell(cell_value)

            if not allocation.is_reservation:
                # For courses, ensure demanda exists before creating allocations
                # Use space-separated atomic blocks as horario_sigaa_bruto
                horario_bruto = " ".join(
                    [f"{dia_sigaa}{bloco}" for bloco in atomic_blocks]
                )
                demanda_id = self.find_demanda(
                    semestre_id,
                    allocation.codigo_disciplina,
                    allocation.turma_disciplina,
                    horario_bruto,  # Like "5T2 5T3" for time slot "5T23"
                    allocation.nome_disciplina,
                )
                if not demanda_id:
                    print(
                        f"  ‚ö†Ô∏è Could not find/create demanda for {allocation.codigo_disciplina} (T{allocation.turma_disciplina})"
                    )
                    continue

                # Now create allocations for each atomic block
                for bloco in atomic_blocks:
                    self.process_allocation(
                        semestre_id,
                        sala.id,
                        dia_obj.id_sigaa,
                        bloco,
                        allocation,
                        demanda_id,
                    )
            else:
                # For reservations, process each atomic block normally
                for bloco in atomic_blocks:
                    self.process_allocation(
                        semestre_id, sala.id, dia_obj.id_sigaa, bloco, allocation
                    )

    def load_csv(self, csv_path: str):
        """Load allocations from CSV file."""

        semestre = self.get_semestre()
        if not semestre:
            print(f"‚ùå Semester '{self.semestre_name}' not found!")
            return False

        print(
            f"Loading historical allocations for semester {semestre.nome} (ID: {semestre.id})"
        )
        print(f"Mode: {'DRY RUN' if self.dry_run else 'LIVE'}")
        print(f"Force mode: {self.force}")

        csv_file = Path(csv_path)
        if not csv_file.exists():
            print(f"‚ùå CSV file not found: {csv_path}")
            return False

        with open(csv_file, "r", encoding="utf-8-sig") as f:
            reader = csv.reader(f, delimiter=";")

            # Read header row with room names
            header_row = next(reader)
            room_mapping = [col.strip() for col in header_row if col.strip()]

            print(f"Found {len(room_mapping)} rooms: {room_mapping[:3]}...")

            # Skip the empty row after header
            next(reader)

            # Process each data row
            for row in reader:
                if not row or not row[0].strip():
                    continue  # Skip empty rows

                self.process_csv_row(row, room_mapping, semestre.id)

        print("\n" + "=" * 50)
        print("LOAD RESULTS:")
        print(f"Rows processed: {self.stats['rows_processed']}")
        print(f"Allocations created: {self.stats['allocations_created']}")
        print(f"Reservas created: {self.stats['reservas_created']}")
        print(f"Demandas created: {self.stats['demandas_created']}")
        print(f"Conflicts skipped: {self.stats['conflicts_skipped']}")
        print(f"Errors: {self.stats['errors']}")

        if not self.dry_run and self.stats["errors"] == 0:
            self.session.commit()
            print("‚úÖ All changes committed to database")
        elif self.dry_run:
            print("üìã Dry run completed (no database changes)")

        return self.stats["errors"] == 0


def main():
    """Main entry point."""
    parser = ArgumentParser(
        description="Load historical semester allocations from CSV",
        formatter_class=RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python load_historical_allocations.py --dry-run
  python load_historical_allocations.py --force docs/Ensalamento\\ Oferta\\ 2-2025.csv
  python load_historical_allocations.py --dry-run /path/to/other.csv
        """,
    )

    parser.add_argument(
        "csv_file",
        nargs="?",
        default="docs/Ensalamento Oferta 2-2025.csv",
        help="Path to CSV file (default: docs/Ensalamento Oferta 2-2025.csv)",
    )

    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes",
    )

    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite existing allocations for conflicts",
    )

    parser.add_argument(
        "--semester",
        default="2025-2",
        help="Semester name (e.g., '2025-2') (default: 2025-2)",
    )

    args = parser.parse_args()

    if args.dry_run and args.force:
        print("‚ùå Cannot use --dry-run and --force together")
        return 1

    with get_db_session() as session:
        allocator = CSVAllocator(
            session,
            dry_run=args.dry_run,
            force=args.force,
            semester_name=args.semester,
        )
        success = allocator.load_csv(args.csv_file)

    return 0 if success else 1


if __name__ == "__main__":
    exit(main())
